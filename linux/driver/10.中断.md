# 一、什么是中断

硬件的通知机制
- 1. 内部中断:CPU执行程序的过程中，发生的一些硬件出错、运算出错事件（如分母为0、溢出等等），不可屏蔽
- 2. 外部中断 : 外设通过一个引脚的高/低电平变化来通知CPU.
# 二、中断处理原理
中断处理有以下2种类型：

- 中断处理程序->分中断处理程序
- 嵌入向量表

# 三、中断接口

## 3.1 中断申请 

```c
int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,const char *name, void *dev)
/*
参数：
	irq：所申请的中断号,linux 的 virtual 中断号，需要特殊函数 把 物理中断转成 virtual irq
	
	handler：该中断号对应的中断处理函数
	flags：中断触发方式或处理方式 
		触发方式：IRQF_TRIGGER_NONE 		//无触发
		 	 	 IRQF_TRIGGER_RISING 	//上升沿触发
			 	 IRQF_TRIGGER_FALLING  //下降沿触发
				IRQF_TRIGGER_HIGH  	//高电平触发
				IRQF_TRIGGER_LOW 		//低电平触发
		处理方式：
			   IRQF_DISABLED		//用于快速中断，处理中屏蔽所有中断
				IRQF_SHARED		  //共享中断
		name：中断名 /proc/interrupts
		dev：传递给中断例程的参数，共享中断时用于区分那个设备，一般为对应设备的结构体地址，无共享中断时写NULL
返回值：成功：0 失败：错误码
*/
```

## 3.2 中断释放

```c
void free_irq(unsigned int irq, void *dev_id)；
/*
功能：释放中断号
参数：
	irq：设备号
	dev_id：共享中断时用于区分那个设备一般强转成设备号，无共享中断时写NULL
*/
```

## 3.3 中断处理函数原型

```c
typedef irqreturn_t (*irq_handler_t)(int, void *);
/*
参数：
	int：中断号（irq）
	void*:对应的申请中断时的dev
返回值：
	typedef enum irqreturn irqreturn_t;	//中断返回值类型
	enum irqreturn {
		IRQ_NONE	= (0 << 0),
		IRQ_HANDLED	= (1 << 0),
		IRQ_WAKE_THREAD	= (1 << 1),
	};
	返回IRQ_HANDLED表示处理完了,返回IRQ_NONE在共享中断表示不处理
*/
```

# 四、按键驱动

按键原理图：

![按键原理图](img/按键原理图.jpg)

exynos4412-fs4412.dts中增加节点

```
mykey2_node {
	compatible = "mykey2,key2";
	key2-gpio = <&gpx1 1 0>;
	interrupt-parent = <&gpx1>;
	interrupts = <1 3>;
};
```

- gpx1 有 24-31 八个中断
- mykey2_node 的 中断 interrupts = <1 3>;，对应 gpx1的<25>号中断，也就是图的 gpx1_1


# 一、上半部与下半部

起源：

1. 中断处理程序执行时间过长引起的问题
2. 有些设备的中断处理程序必须要处理一些耗时操作

# 二、下半部机制之tasklet ---- 基于软中断

## 6.1 结构体
```c
struct tasklet_struct
{
​	struct tasklet_struct *next;
​	unsigned long state;
​	atomic_t count;
​	void (*func)(unsigned long);
​	unsigned long data;

};
```


## 6.2 定义tasklet的中断底半部处理函数

void tasklet_func(unsigned long data);

## 6.3 初始化tasklet

```c
DECLARE_TASKLET(name, func, data);
/*
定义变量并初始化
参数：name:中断底半部tasklet的名称
	 Func:中断底半部处理函数的名字
	 data:给中断底半部处理函数传递的参数
*/
```

```c
void tasklet_init(struct tasklet_struct *t,void (*func)(unsigned long), unsigned long data)
```

## 6.4 调度tasklet

```c
void tasklet_schedule(struct tasklet_struct *t)
//参数:t:tasklet的结构体
```

# 三、按键驱动之tasklet版

# 四、workqueue(基于内核线程)
- 以下都是使用 共享workqueue队列,也就是 内核默认创建的 wq.
- 可以为每个设备单独 创建 workqueue,见 ldd3的第七章

## 8.1 工作队列结构体：
```c
typedef void (*work_func_t)(struct work_struct  *work)

//提交给 工作队列的任务定义如下
struct work_struct {
​		atomic_long_t data;				//传递给 func 的参数？
​		struct list_head entry;			//链表项
​		work_func_t func;				//要持续的函数
\#ifdef CONFIG_LOCKDEP
​			struct lockdep_map lockdep_map;

\#endif

};
```



## 8.2 处理函数原型
```c
 typedef void (*work_func_t)(struct work_struct  *work)
 void work_queue_func(struct work_struct  *work);
```

## 8.3 初始化工作队列的work

```c
struct work_struct jig work;

//初始化：绑定工作队列及工作队列的底半部处理函数
 INIT_WORK(struct work_struct * pwork, _func,void *data);

// 参数：pwork：添加的 task
// ​func：工作队列的底半部处理函数
```




## 8.4 工作队列的调度函数
```c

bool schedule_work(struct work_struct *work)；
bool schedule_delayed_work(struct work_struct *work, unsigned long delay);// 先延迟 delay 个 jiffies


// 返回 0 表示 添加成功
//   非0 表示 已经添加过了，添加失败 
```


# 五、按键驱动之workqueue版



# 六、下半部机制比较

任务机制

​	workqueue  ----- 内核线程  能睡眠  运行时间无限制

异常机制  -------  不能睡眠  下半部执行时间不宜太长（ < 1s)

​	软中断  ----  接口不方便

​	tasklet  ----- 无具体延后时间要求时

​	定时器  -----有具体延后时间要求时








