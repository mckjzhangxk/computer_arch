# 一、内核内存管理框架


- 4KB 称之为一页,struct page来表示
- 伙伴关系法维护.
![内存管理1](img/内存管理1.jpg)

内核地址空间划分图：

![虚拟内核空间划分图](img/虚拟内核空间划分图.png)

- <font color=red>0-3G,留给用户进程(比如 进程内核态使用的栈)，3G-4G留给自己使用。</font>
​
- 1G kernel space 细分为：ZONE_DMA(0-16M)、ZONE_NORMAL(16M-896M),ZONE_HIGH(>896M)
- - ZONE_DMA(x86:0-16M)、
- - ZONE_NORMAL(16M-896M):<font color=red>direct mapping.页表建立好了</font>

分配方式：
```c
                    virt = phys + PAGE_OFFSET
					1. kmalloc:小内存分配，slab算法
					2. get_free_page：整页分配，2的n次方页，n最大为10
```

- 高端内存(896M-1G):页表没建立。细分为：vmalloc区、持久映射区、固定映射区

分配方式：
```c
分配方式：vmalloc：虚拟地址连续，物理地址不连续
```
​							

​                                               
# 二、常用动态分配

## 2.1 kmalloc

​	函数原型：

```c
// 1.kmalloc() 位于direct-mapping，物理上是连续的.
// 2。virt = phys + PAGE_OFFSET
// 3.由于要求物理连续， 限制 size<=128KB。 
void *kmalloc(size_t size, gfp_t flags);

void kfree(const void *objp);
//强制清零
void *kzalloc(size_t size, gfp_t flags)
```
　　 
较常用的 flags（分配内存的方法）：

- **GFP_ATOMIC** —— 分配内存的过程是一个原子过程，分配内存的过程不会被（高优先级进程或中断）打断；
- **GFP_KERNEL** —— 正常分配内存；
- **GFP_DMA** —— 给 DMA 控制器分配内存，需要使用该标志（DMA要求分配虚拟地址和物理地址连续）。


```c
flags 的参考用法： 
　|– 进程上下文，可以睡眠　　　　　GFP_KERNEL 
　|– 异常上下文，不可以睡眠　　　　GFP_ATOMIC 
　|　　|– 中断处理程序　　　　　　　GFP_ATOMIC 
　|　　|– 软中断　　　　　　　　　　GFP_ATOMIC 
　|　　|– Tasklet　　　　　　　　　GFP_ATOMIC 
　|– 用于DMA的内存，可以睡眠　　　GFP_DMA | GFP_KERNEL 
　|– 用于DMA的内存，不可以睡眠　　GFP_DMA |GFP_ATOMIC 
　　 
```


## 2.2 _get_free_page
```c
//按页分配
// 分配 2^order 个 page
unsigned long _get_free_pages (unsigned int flags, unsigned int order);
// 分配 2^0 个 page
unsigned long _get_free_page(unsigned int flags);
// 清0版本
unsigned long get_zeroed_page (unsigned int flags) ;


void free_page(unsigned long addr):
void free_pages (unsigned long addr, unsigned long order);
```

## 2.3 vmalloc

```c
// 1.vmalloc() vm space 分配块连续的内存区，但对应物理内存中并不一定连续。
// 2.由于 物理内存不连续， 所以 size 不受限制。
// 3.适合申请 大内存。
void *vmalloc(unsigned long size);


void vfree(const void *addr);
```



## 2.4 高速缓存
- kmem_cache(见LDD 3,p217): 固定大小的 预分配对象
- mempool(见LDD 3)