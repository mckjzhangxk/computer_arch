# 一、起源

- 减少垃圾代码,分离 kernel与 外设属性配置
- 参考Open Fireware设计



# 二、基本组成

两种源文件：

1. xxxxx.dts dts是device tree source的缩写
2. xxxxx.dtsi  dtsi是device tree source include的缩写，这样的文件用于被dts文件包含
3. xxxxx.dtb, dts文件编译成对应的二进制文件,便于运行时存放在内存加快读取信息的速度


# 三、基本语法

- 节点组成，节点下 包含0或多个子节点
- 根节点：描述整个开发板硬件平台，其它节点用来表示具体设备、总线的属性信息
- 节点可以有多个属性，每个属性用key-value键值对来表示

节点语法：

```c
[label:] node-name[@unit-address] {    
	[properties definitions];    
	[child nodes];
};

label: 节点别名,&label 来表示引用指定节点
node-name: 节点名
unit-address: 设备地址，一般填写该设备寄存器组或内存块的首地址
properties definitions：属性定义
child nodes:子节点
```

属性语法：

```c
[label:] property-name = value;
[label:] property-name;

属性可以无值
有值的属性，可以有三种取值：
1. <>:相当于 uint32数组 或者 uint64数组,空格分隔元素,，取决于平台位数。
2. string:用双引号表示(" ")
3. []:相当于 uint8数组,空格分隔元素。
4. 用,分隔的多值： eg myvalue = <1 2 3> , "123" , [1 2 3]
    
```

# 四、特殊节点
- [参考配置](../qemu/设备树demo/vexpress-v2p-ca9.dts)
## 4.1 根节点

根节点表示整块开发板的信息


```c
#address-cells   // 在子节点的reg属性中, address 占几个 u32
#size-cells      // 在子节点的reg属性， size 占几个 u32
compatible       // 驱动和设备（设备节点）的匹配依据                      
model            // 开发版名字？


//eg
/ {
	model = "V2P-CA9";
	compatible = "arm,vexpress,v2p-ca9", "arm,vexpress";
	#address-cells = <1>;
	#size-cells = <1>;
};
```

## 4.2 /memory

所有设备树文件的必需节点,它定义了系统物理内存的 layout

```c
device_type = "memory";
reg  =<address size>   //用来指定内存的地址、大小

// eg:
memory@60000000 {
		device_type = "memory";
		reg = <0x60000000 0x40000000>;
};
```

## 4.3  /chosen

传递内核启动时使用的参数parameter

```c
bootargs  //字符串，内核启动参数, 跟u-boot中设置的bootargs作用一样

chosen { 
	bootargs: "......"
};
```

## 4.4 /cpus  多核CPU支持

/cpus节点下有 >=1 个cpu子节点, cpu子节点 用reg属性用 设置 cpuid

所以 /cpus 中有以下2个属性:

```c
#address-cells   // reg 的address 占几个 u32
#size-cells      // reg 的size 占几个 u32,一定是0

//eg:
cpus {
		#address-cells = <1>;
		#size-cells = <0>;

		cpu@0 {
			device_type = "cpu";
			compatible = "arm,cortex-a9";
			reg = <0>;
			next-level-cache = <&L2>;
		};
		cpu@1 {
			device_type = "cpu";
			compatible = "arm,cortex-a9";
			reg = <1>;
			next-level-cache = <&L2>;
		};
};

```

# 五、常用属性

## 5.1 phandle

​	数字形式的节点标识，在后续节点中属性值性质表示某节点时，可以引用对应节点

​    如：

```
pic@10000000 {    
	phandle = <1>;    
	interrupt-controller;
};
another-device-node {    
	interrupt-parent = <1>;   // 使用phandle值为1来引用上述节点
};
```

## 5.2 <font color=red>地址</font>

reg属性：表示内存区域region，语法：

```c
reg = <address1 length1 [address2 length2] [address3 length3]>;
//#address-cells ,#size-cells 两个属性共同决定 address,length 的长度
```


## 5.3 <font color=red>compatibe</font>

驱动和设备（设备节点）的匹配依据，compatible（兼容性）的值可以有不止一个字符串以满足不同的需求，语法：

```
compatible = "字符串1","字符串2",...;
```

## 5.4 <font color=red>中断 </font>

- a. 中断控制器节点用的属性：

```c
interrupt-controller： 表示节点是一个中断控制器
#interrupt-cells : 表示 中断描述符 需要 占用几个u32
```
```c
	//eg
	gic: interrupt-controller@1e001000 {//ARM Generic Interrupt Controller
		interrupt-controller;
		#interrupt-cells = <3>;		   // 一个中断描述符需要 3 个u32
		compatible = "arm,cortex-a9-gic";
		#address-cells = <0>;          // ?
		reg = <0x1e001000 0x1000>,
		      <0x1e000100 0x100>;
	};
```
b. 中断源 的属性：

- 参考文档：Documentation/devicetree/bindings/interrupt-controller/
```c
interrupt-parent = <引用某中断控制器节点> // 标识设置属于哪个中断控制器，子节点继承父节点本属性


interrupts = <desc1 desc2>  // 中断标识符列表,由于多个中断描述符组成


中断描述符(desc{i})： 由 #interruot-cells 定义大小, 所属控制器来 格式。

// eg: open PIC–compatible格式的描述符如下
// <中断号 触发编码>
| 触发方式|编码|
|        -|-|
|上升沿触发 |1|
|下降沿触发 |2|
|高电平触发 |3|
|低电平触发 |4|
```

```c
// eg
/ {
	model = "V2P-CA9";
	interrupt-parent = <&gic>;  //设置 所属的中断控制器

	gic: interrupt-controller@1e001000 {//见arm,gic.yaml总的#interrupt-cells描述 
		interrupt-controller;
		#interrupt-cells = <3>;		   // 一个中断描述符=3个u32
	};

	timer@100e4000 {// 继承interrupt-parent 
		reg = <0x100e4000 0x1000>;
		interrupts = <0 48 4>,<0 49 4>; // 2个描述符，每个占用3个 u32
	};

	watchdog@100e5000 {// 继承interrupt-parent 
		interrupts = <0 51 4>;	// <SPI, irq_num,触发编码>
	};

};

| 触发方式|编码|
|        -|-|
|上升沿触发 |1|
|下降沿触发 |2|
|低电平触发 |4|
|高电平触发 |8|
```
## 5.5 <font color=red>gpio</font>
- 参考 Documentation/devicetree/bindings/gpio/gpio.txt
a. 对于GPIO控制器：
```c
gpio-controller //无值空属性，表明节点是 gpio控制器
#gpio-cells=<3>，//引脚描述符占用的 u32数量
```
b. 对于GPIO使用者节点：

gpio使用节点的属性

```
xxx-gpio = <&引用GPIO控制器 GPIO标号 工作模式>
工作模式：
1 低电平有效 GPIO_ACTIVE_HIGH
0 高电平有效 GPIO_ACTIVE_LOW
```

## 5.6 属性设置套路
- 查看源码目录下：Documentation/devicetree/binding的配置教程

# 六、常用接口

struct device_node  对应设备树中的一个节点
struct property 对应节点中一个属性

## 6.1 of_find_node_by_path

```c
/**
include/of.h
of_find_node_by_path - 通过路径查找指定节点
@path - 带全路径的节点名，也可以是节点的别名
成功：得到节点的首地址；失败：NULL
*/
struct device_node * of_find_node_by_path(const char *path);
```

## 6.2 of_find_property

```c
/*
include/of.h
of_find_property - 提取指定属性的值
@np - 设备节点指针
@name - 属性名称
@lenp - 属性值的字节数
成功：属性值的首地址；失败：NULL
*/
struct property *of_find_property(const struct device_node *np, const char *name, int *lenp);
```

## 6.3 of_get_named_gpio

```c
/**
 * include/of_gpio.h
 * of_get_named_gpio - 从设备树中提取gpio口
 * @np - 设备节点指针
 * @propname - 属性名
 * @index - gpio口引脚标号 
 * 成功：得到GPIO口编号；失败：负数，绝对值是错误码
 */
int of_get_named_gpio(struct device_node *np, const char *propname, int index);
```

## 6.4 irq_of_parse_and_map

```c
/*
	功能：获得设备树中的中断号并进行映射
	参数：node：设备节点
		 index:序号
	返回值：成功：中断号	失败：错误码
*/
unsigned int irq_of_parse_and_map(struct device_node *node, int index)；
```

## 6.5 读属性值

of_property_read_string

```c
/*
of_property_read_string - 提取字符串（属性值）
@np - 设备节点指针
@propname - 属性名称
@out_string - 输出参数，指向字符串（属性值）
成功：0；失败：负数，绝对值是错误码
*/
int of_property_read_string(struct device_node *np, const char *propname, const char **out_string);
```

读数值

```c
int of_property_read_u8(const struct device_node *np,const char *propname,u8 *out_value)

int of_property_read_u16(const struct device_node *np,const char *propname,u16 *out_value)

int of_property_read_u32(const struct device_node *np,const char *propname,u32 *out_value)
```

判断属性是否存在

```c
int of_property_read_bool(const struct device_node *np,const char *propname)
```

读数组

```c
int of_property_read_u32_array(const struct device_node *np,const char *propname,u32 *out_value,size_t sz)
```

# 七、GPIO接口

## 7.1 向内核申请GPIO

int gpio_request(unsigned gpio,const char *label) 

功能：其实就是让内核检查一下该GPIO引脚是否被其它设备占用，如果没有占用则返回0并用label做一下标记，表示被本设备占用，否则返回负数



void gpio_free(unsigned gpio)

功能：去除本设备对该GPIO的占用标记，表示本设备向内核归还对该GPIO引脚的使用权，此后其它设备可占用该GPIO引脚



## 7.2 设置GPIO方向

int gpio_direction_input(unsigned gpio)

int gpio_direction_output(unsigned gpio,int default_value)

## 7.3 读写GPIO数据

int gpio_get_value(unsigned gpio)

int gpio_set_value(unsigned gpio,int value)



# 八、led驱动设备树版

[my_cdev_led_dt.c](code/my_cdev_led_dt.c)

1. 在设备树源文件的根节点下添加本设备的节点（该节点中包含本设备用到的资源信息）

   ..../linux3.14/arch/arm/boot/dts/exynos4412-fs4412.dts

```
fs4412-leds {
	compatible = "fs4412,led2-5";
	led2-gpio = <&gpx2 7 0>;
	led3-gpio = <&gpx1 0 0>;
	led4-gpio = <&gpf3 4 0>;
	led5-gpio = <&gpf3 5 0>;
};
```

 2. 在linux内核源码的顶层目录下执行：make dtbs  （生成对应的dtb文件）

 3. cp   ?????.dtb   /tftpboot

 4. 编写驱动代码：

    a. 通过本设备在设备树中的路径找到对应节点（struct device_node类型的地址值）

    b. 调用 of_get_named_gpio 函数得到某个GPIO的编号

    c. struct leddev结构体中记录所有用到的GPIO编号

    d. 使用某个GPIO引脚前需先通过gpio_request函数向内核申请占用该引脚，不用该引脚时可通过gpio_free归还给内核

    e. 通过gpio_direction_input和gpio_direction_output函数来设置某个GPIO的作用

    f. 通过gpio_get_value函数可以获取某个GPIO引脚的当前电平

    g.  通过gpio_set_value函数可以改变某个GPIO引脚的电平