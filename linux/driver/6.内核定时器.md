## 时钟中断
- 硬件设备每间隔t 产生一个时钟中断,称为一个tick
- 时钟中断程序 把全局的jiffies_64+1,jiffies是jiffies_64的低32位。
- HZ是内核的一个宏，t=1/HZ,一般100-200

## 延迟机制
- 分类1： 短延迟，长延迟
- 分类2： 忙等待类(whie(1))，阻塞类(sleep)
- 异常上下文中只能采用忙等待类
- 任务上下文短延迟采用忙等待类，长延迟采用阻塞类
```c
// 1. 短延迟：忙等待, 也就是 for-loop
void ndelay(unsigned long nsecs)
void udelay(unsigned long usecs)
void mdelay(unsigned long msecs)


// 2. 长延迟：忙等待,依赖 jiffies

time_after(a,b)    //a > b
time_before(a,b)   //a < b

#define time_after(a,b)  (long)(a) - (long)(b) > 0
//如果给定 b,定义
// U={b+1,b+2,...b+2^31-1},是大于 b 的集合
// V={b-2^31,b-2^31+1,...b-1},是小于 b 的集合

// time_after(a,b)==1 等价于 a in U.如果 a在 U， a-b 必然 在 [0,2^31-1],是有符号正数

// time_after(a,b) 等价于 a in V， 如果 a在 V， a-b 必然 在 [-1,-2^31],是有符号负数

//延迟100个jiffies
unsigned long delay = jiffies + 100;
while(time_before(jiffies,delay));
//延迟2s
unsigned long delay = jiffies + 2*HZ;
while(time_before(jiffies,delay));


// 3.睡眠延迟----阻塞类
void msleep(unsigned int msecs);   
unsigned long msleep_interruptible(unsigned int msecs);//可以被信号中断
void ssleep(unsigned int secs); 
```




## 定时器
- 不是在进程上下文执行,原子性上下文

[my_cdev_timer.c](code/my_cdev_timer.c)