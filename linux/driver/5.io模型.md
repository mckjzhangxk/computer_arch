## 5种IO模型
- 阻塞
- 非阻塞
![alt text](img/非阻塞.jpg)
- 多路复用
- 信号:收到信号后读
- 异步IO(DMA):收到信号后读完成


## 阻塞

- 就系队列：runnable 的进程，可以被scheduler调度。
- 等待队列：资源不满足的情况下把进程插入到此队列，此队列的进程不会被scheduler调度，进程是sleep态。
- 等待队列分为2中，可被信号中断的 和不可 被信号中断的
- 一旦满足再次被调用条件，需要wakeup 等待队列
- [block_demo.c](data/io_block_demo.c)
```c
// 应用层设置 阻塞与非阻塞
void set_fd_noblock(int fd) {
    int flag = fcntl(fd, F_GETFD);
    fcntl(fd, F_SETFD, flag | O_NONBLOCK);
}
void set_fd_block(int fd) {
    int flag = fcntl(fd, F_GETFD);
    fcntl(fd, F_SETFD, flag & (~O_NONBLOCK) );
}
```

```c
// 驱动层等待队列 
wait_queue_head_t wq//等待队列头数据类型
init_waitqueue_head(wait_queue_head_t *pwq) //初始化等待队列头
    
// 睡眠
wait_event_interruptible(wq,condition)
/*
功能：条件不成立则让任务进入浅度睡眠，直到条件成立醒来
    wq:等待队列头
    condition：C语言表达式
返回：正常唤醒返回0，信号唤醒返回非0（此时读写操作函数应返回-ERESTARTSYS）
*/
        
wait_event(wq,condition) //深度睡眠


// 唤醒
wake_up_interruptible(wait_queue_head_t *pwq)  
wake_up(wait_queue_head_t *pwq)

```

- linux 底层的实现，wait 的实现
```c
    //wait_event_interruptible(wq,condition)宏的展开
	DEFINE_WAIT(__wait);								
	while(1) {							
		prepare_to_wait(&wq, &__wait, TASK_INTERRUPTIBLE);
		if (condition)						
			break;			
        // <--- 如果这里发生 wakeup_event(&wq)会有 导致长期睡眠吗？
        //不会：  因为 prepare_to_wait已经把 当前进程 加入了 wq, wakeup_event
        // 如果在这里发生，会把 进程状态从 TASK_UNINTERRUPTIBLE 改成 runnable
        // 后面的 schedule立刻 返回，			
		if (!signal_pending(current)) {//没信号的时候执行 切换上下文		
			schedule();					
			continue;					
		}							
		ret = -ERESTARTSYS;					
		break;							
	}								
	finish_wait(&wq, &__wait);					

     //wait_event(wq,condition)宏的展开
    DEFINE_WAIT(__wait);
	while(1) {	
		prepare_to_wait(&wq, &__wait, TASK_UNINTERRUPTIBLE);
		if (condition)						
			break;		
        // <--- 如果这里发生 wakeup_event(&wq)会有 导致长期睡眠吗？
        //不会：  因为 prepare_to_wait已经把 当前进程 加入了 wq, wakeup_event
        // 如果在这里发生，会把 进程状态从 TASK_UNINTERRUPTIBLE 改成 runnable
        // 后面的 schedule立刻 返回，
		schedule();						
	}
	finish_wait(&wq, &__wait);	
```
- wakeup 的实现
```c

#define wake_up(x)			__wake_up(x, TASK_NORMAL, 1, NULL)
#define wake_up_all(x)			__wake_up(x, TASK_NORMAL, 0, NULL)
#define wake_up_interruptible(x)	__wake_up(x, TASK_INTERRUPTIBLE, 1, NULL)

// mode: TASK_NORMAL,或者 TASK_INTERRUPT
// nr_exclusive:0 表示唤起所有， 否则表示唤起的数量
// sync： 1
// key：NULL

//kernel/sched.c
static void __wake_up_common(wait_queue_head_t *q, unsigned int mode,
			     int nr_exclusive, int sync, void *key)
{
	wait_queue_t *curr, *next;

    //遍历队列，执行 队里项的 func
    // func 最终调用 try_to_wake_up(struct task_struct *p, unsigned int state, int sync)，改变进程的状态位 runnable, 把进程放入到 cpu.rq（运行队列中）
	list_for_each_entry_safe(curr, next, &q->task_list, task_list) {
		unsigned flags = curr->flags;

		//try_to_wake_up(curr->private, mode, sync);
		if (curr->func(curr, mode, sync, key) &&
				(flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)
			break;
	}
}

```
```c

//见 include/linux/wait.h

// wait_queue_head_t代表【队列】
struct __wait_queue_head {
	spinlock_t lock;
	struct list_head task_list;
};
typedef struct __wait_queue_head wait_queue_head_t;


// wait_queue_t代表【队列项】
struct __wait_queue {
	unsigned int flags;
	void *private;
	wait_queue_func_t func;
	struct list_head task_list;
};
typedef struct __wait_queue wait_queue_t;

// 定义一个 wait 的【队列项】
#define DEFINE_WAIT(name)						\
	wait_queue_t name = {						\
		.private	= current,				\
		.func		= autoremove_wake_function,		\
		.task_list	= LIST_HEAD_INIT((name).task_list),	\
	}

// 见kernel/wait.c
void init_waitqueue_head(wait_queue_head_t *q)
{
	spin_lock_init(&q->lock);
	INIT_LIST_HEAD(&q->task_list);
}

void add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait)
{
	unsigned long flags;

	wait->flags &= ~WQ_FLAG_EXCLUSIVE;
	spin_lock_irqsave(&q->lock, flags);
    list_add(&q->task_list, &wait->task_list);//链表添加操作而已
	spin_unlock_irqrestore(&q->lock, flags);
}

// 把当前进程的状态改成 state
void prepare_to_wait(wait_queue_head_t *q, wait_queue_t *wait, int state)
{
	unsigned long flags;

	wait->flags &= ~WQ_FLAG_EXCLUSIVE;
	spin_lock_irqsave(&q->lock, flags);
	if (list_empty(&wait->task_list))//list_empty(&q->task_list) 也可以
		__add_wait_queue(q, wait);
	/*
	 * don't alter the task state if this is just going to
	 * queue an async wait queue callback
	 */
	if (is_sync_wait(wait))
		set_current_state(state);
	spin_unlock_irqrestore(&q->lock, flags);
}

//从 q 中 移除【队列项】wait
void finish_wait(wait_queue_head_t *q, wait_queue_t *wait)
{
	unsigned long flags;

	__set_current_state(TASK_RUNNING);
	/*
	 * We can check for list emptiness outside the lock
	 * IFF:
	 *  - we use the "careful" check that verifies both
	 *    the next and prev pointers, so that there cannot
	 *    be any half-pending updates in progress on other
	 *    CPU's that we haven't seen yet (and that might
	 *    still change the stack area.
	 * and
	 *  - all other users take the lock (ie we can only
	 *    have _one_ other CPU that looks at or modifies
	 *    the list).
	 */
	if (!list_empty_careful(&wait->task_list)) {
		spin_lock_irqsave(&q->lock, flags);
		list_del_init(&wait->task_list);
		spin_unlock_irqrestore(&q->lock, flags);
	}
}
```


## 多路复用
- select,poll,epoll三种实现
- - select: 描述符数量受限，效率低
- - poll: 链表实现，数量不受限，效率低
- - epoll: 数量不受限，效率高
- 见[poll_demo.c](data/io_poll_demo.c)

## 信号驱动
- 见 [signal_demo.c](data/io_signal_demo.c)